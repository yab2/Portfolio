/*
    A JavaScript plugin for lazy-loading responsive Google Adsense ads.
    -
    By Osvaldas Valutis, www.osvaldas.info
    Available for use under the MIT License
*/

// Sticky Plugin v1.0.4 for jQuery
// =============
// Author: Anthony Garand
// Improvements by German M. Bravo (Kronuz) and Ruud Kamphuis (ruudk)
// Improvements by Leonardo C. Daronco (daronco)
// Created: 02/14/2011
// Date: 07/20/2015
// Website: http://stickyjs.com/
// Description: Makes an element on the page stick on the screen as you scroll
//              It will only set the 'top' and 'position' of your element, you
//              might need to adjust the width in some cases.

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof module === 'object' && module.exports) {
        // Node/CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    var slice = Array.prototype.slice; // save ref to original slice()
    var splice = Array.prototype.splice; // save ref to original slice()

    var defaults = {
            topSpacing: 0,
            bottomSpacing: 0,
            className: 'is-sticky',
            wrapperClassName: 'sticky-wrapper',
            center: false,
            getWidthFrom: '',
            widthFromWrapper: true, // works only when .getWidthFrom is empty
            responsiveWidth: false,
            zIndex: 'inherit',
            scrollStickyElement: false
        },
        $window = $(window),
        $document = $(document),
        sticked = [],
        windowHeight = $window.height(),
        lastScroll = $window.scrollTop(),
        stickyOffest = 0,
        scroller = function() {
            var scrollTop = $window.scrollTop(),
                documentHeight = $document.height(),
                dwh = documentHeight - windowHeight,
                extra = (scrollTop > dwh) ? dwh - scrollTop : 0;

            for (var i = 0, l = sticked.length; i < l; i++) {
                var s = sticked[i],
                    elementTop = s.stickyWrapper.offset().top,
                    etse = elementTop - s.topSpacing - extra;

                //update height in case of dynamic content
                s.stickyWrapper.css('height', s.stickyElement.outerHeight());

                if (scrollTop <= etse) {
                    if (s.currentTop !== null) {
                        s.stickyElement
                            .css({
                                'width': '',
                                'position': '',
                                'top': '',
                                'z-index': ''
                            });
                        s.stickyElement.parent().removeClass(s.className);
                        s.stickyElement.trigger('sticky-end', [s]);
                        s.currentTop = null;
                    }
                }
                else {
                    var newTop = documentHeight - s.stickyElement.outerHeight()
                        - s.topSpacing - s.bottomSpacing - scrollTop - extra;
                    if (newTop < 0) {
                        newTop = newTop + s.topSpacing;
                    } else {
                        newTop = s.topSpacing;
                    }

                    if (s.scrollStickyElement) {
                        //also scroll the sticky element if its higher from window
                        if (s.stickyElement.outerHeight() > windowHeight) {
                            var scrollDiff = scrollTop - lastScroll;
                            var newStickyOffest = stickyOffest - scrollDiff;

                            if (scrollDiff > 0) {
                                //down
                                if ((s.stickyElement.outerHeight() + stickyOffest) > windowHeight) {
                                    stickyOffest = newStickyOffest;
                                    if (stickyOffest < (windowHeight - s.stickyElement.outerHeight())) {
                                        stickyOffest = windowHeight - s.stickyElement.outerHeight();
                                    }
                                }
                                newTop = stickyOffest;
                            } else if (s.currentTop < 0) {
                                //up
                                newTop = stickyOffest = newStickyOffest;
                            } else {
                                newTop = 0;
                            }
                        }
                    }

                    lastScroll = scrollTop;

                    if (s.currentTop !== newTop) {
                        var newWidth;
                        if (s.getWidthFrom) {
                            padding =  s.stickyElement.innerWidth() - s.stickyElement.width();
                            newWidth = $(s.getWidthFrom).width() - padding || null;
                        } else if (s.widthFromWrapper) {
                            newWidth = s.stickyWrapper.width();
                        }
                        if (newWidth == null) {
                            newWidth = s.stickyElement.width();
                        }
                        s.stickyElement
                            .css('width', newWidth)
                            .css('position', 'fixed')
                            .css('top', newTop)
                            .css('z-index', s.zIndex);

                        s.stickyElement.parent().addClass(s.className);

                        if (s.currentTop === null) {
                            s.stickyElement.trigger('sticky-start', [s]);
                        } else {
                            // sticky is started but it have to be repositioned
                            s.stickyElement.trigger('sticky-update', [s]);
                        }

                        if (s.currentTop === s.topSpacing && s.currentTop > newTop || s.currentTop === null && newTop < s.topSpacing) {
                            // just reached bottom || just started to stick but bottom is already reached
                            s.stickyElement.trigger('sticky-bottom-reached', [s]);
                        } else if(s.currentTop !== null && newTop === s.topSpacing && s.currentTop < newTop) {
                            // sticky is started && sticked at topSpacing && overflowing from top just finished
                            s.stickyElement.trigger('sticky-bottom-unreached', [s]);
                        }

                        s.currentTop = newTop;
                    }

                    // Check if sticky has reached end of container and stop sticking
                    var stickyWrapperContainer = s.stickyWrapper.parent();
                    var unstick = (s.stickyElement.offset().top + s.stickyElement.outerHeight() >= stickyWrapperContainer.offset().top + stickyWrapperContainer.outerHeight()) && (s.stickyElement.offset().top <= s.topSpacing);

                    if( unstick ) {
                        s.stickyElement
                            .css('position', 'absolute')
                            .css('top', '')
                            .css('bottom', 0)
                            .css('z-index', '');
                    } else {
                        s.stickyElement
                            .css('position', 'fixed')
                            .css('top', newTop)
                            .css('bottom', '')
                            .css('z-index', s.zIndex);
                    }
                }
            }
        },
        resizer = function() {
            windowHeight = $window.height();

            for (var i = 0, l = sticked.length; i < l; i++) {
                var s = sticked[i];
                var newWidth = null;
                if (s.getWidthFrom) {
                    if (s.responsiveWidth) {
                        newWidth = $(s.getWidthFrom).width();
                    }
                } else if(s.widthFromWrapper) {
                    newWidth = s.stickyWrapper.width();
                }
                if (newWidth != null) {
                    s.stickyElement.css('width', newWidth);
                }
            }
        },
        methods = {
            init: function(options) {
                return this.each(function() {
                    var o = $.extend({}, defaults, options);
                    var stickyElement = $(this);

                    var stickyId = stickyElement.attr('id');
                    var wrapperId = stickyId ? stickyId + '-' + defaults.wrapperClassName : defaults.wrapperClassName;
                    var wrapper = $('<div></div>')
                        .attr('id', wrapperId)
                        .addClass(o.wrapperClassName);

                    stickyElement.wrapAll(function() {
                        if ($(this).parent("#" + wrapperId).length == 0) {
                            return wrapper;
                        }
                    });

                    var stickyWrapper = stickyElement.parent();

                    if (o.center) {
                        stickyWrapper.css({width:stickyElement.outerWidth(),marginLeft:"auto",marginRight:"auto"});
                    }

                    if (stickyElement.css("float") === "right") {
                        stickyElement.css({"float":"none"}).parent().css({"float":"right"});
                    }

                    o.stickyElement = stickyElement;
                    o.stickyWrapper = stickyWrapper;
                    o.currentTop    = null;

                    sticked.push(o);

                    methods.setWrapperHeight(this);
                    methods.setupChangeListeners(this);
                });
            },

            setWrapperHeight: function(stickyElement) {
                var element = $(stickyElement);
                var stickyWrapper = element.parent();
                if (stickyWrapper) {
                    stickyWrapper.css('height', element.outerHeight());
                }
            },

            setupChangeListeners: function(stickyElement) {
                if (window.MutationObserver) {
                    var mutationObserver = new window.MutationObserver(function(mutations) {
                        if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) {
                            methods.setWrapperHeight(stickyElement);
                        }
                    });
                    mutationObserver.observe(stickyElement, {subtree: true, childList: true});
                } else {
                    if (window.addEventListener) {
                        stickyElement.addEventListener('DOMNodeInserted', function() {
                            methods.setWrapperHeight(stickyElement);
                        }, false);
                        stickyElement.addEventListener('DOMNodeRemoved', function() {
                            methods.setWrapperHeight(stickyElement);
                        }, false);
                    } else if (window.attachEvent) {
                        stickyElement.attachEvent('onDOMNodeInserted', function() {
                            methods.setWrapperHeight(stickyElement);
                        });
                        stickyElement.attachEvent('onDOMNodeRemoved', function() {
                            methods.setWrapperHeight(stickyElement);
                        });
                    }
                }
            },
            update: scroller,
            unstick: function(options) {
                return this.each(function() {
                    var that = this;
                    var unstickyElement = $(that);

                    var removeIdx = -1;
                    var i = sticked.length;
                    while (i-- > 0) {
                        if (sticked[i].stickyElement.get(0) === that) {
                            splice.call(sticked,i,1);
                            removeIdx = i;
                        }
                    }
                    if(removeIdx !== -1) {
                        unstickyElement.unwrap();
                        unstickyElement
                            .css({
                                'width': '',
                                'position': '',
                                'top': '',
                                'float': '',
                                'z-index': ''
                            })
                        ;
                    }
                });
            }
        };

    // should be more efficient than using $window.scroll(scroller) and $window.resize(resizer):
    if (window.addEventListener) {
        window.addEventListener('scroll', scroller, false);
        window.addEventListener('resize', resizer, false);
    } else if (window.attachEvent) {
        window.attachEvent('onscroll', scroller);
        window.attachEvent('onresize', resizer);
    }

    $.fn.sticky = function(method) {
        if (methods[method]) {
            return methods[method].apply(this, slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.sticky');
        }
    };

    $.fn.unstick = function(method) {
        if (methods[method]) {
            return methods[method].apply(this, slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method ) {
            return methods.unstick.apply( this, arguments );
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.sticky');
        }
    };
    $(function() {
        setTimeout(scroller, 0);
    });
}));

/*jshint browser:true */
/*!
* FitVids 1.1
*
* Copyright 2013, Chris Coyier - http://css-tricks.com + Dave Rupert - http://daverupert.com
* Credit to Thierry Koblentz - http://www.alistapart.com/articles/creating-intrinsic-ratios-for-video/
* Released under the WTFPL license - http://sam.zoy.org/wtfpl/
*
*/
;(function( $ ) {

	'use strict';

	$.fn.fitVids = function( options ) {
		var settings = {
			customSelector: null,
			ignore: null
		};

		if ( ! document.getElementById( 'fit-vids-style' ) ) {
			// appendStyles: https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.js
			var head = document.head || document.getElementsByTagName( 'head' )[0];
			var css = '.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}';
			var div = document.createElement( 'div' );
			div.innerHTML = '<p>x</p><style id="fit-vids-style">' + css + '</style>';
			head.appendChild( div.childNodes[1] );
		}

		if ( options ) {
			$.extend( settings, options );
		}

		return this.each(function() {
			var selectors = [
				'iframe[src*="player.vimeo.com"]',
				'iframe[src*="youtube.com"]',
				'iframe[src*="youtube-nocookie.com"]',
				'iframe[src*="kickstarter.com"][src*="video.html"]',
				'object',
				'embed'
			];

			if ( settings.customSelector ) {
				selectors.push( settings.customSelector );
			}

			var ignoreList = '.fitvidsignore';

			if ( settings.ignore ) {
				ignoreList = ignoreList + ', ' + settings.ignore;
			}

			var $allVideos = $( this ).find( selectors.join( ',' ) );
			$allVideos = $allVideos.not( 'object object' ); // SwfObj conflict patch
			$allVideos = $allVideos.not( ignoreList ); // Disable FitVids on this video.

			$allVideos.each(function( count ) {
				var $this = $( this );
				if ( $this.parents( ignoreList ).length > 0 ) {
					return; // Disable FitVids on this video.
				}
				if ( this.tagName.toLowerCase() === 'embed' && $this.parent( 'object' ).length || $this.parent( '.fluid-width-video-wrapper' ).length ) {
					return;
				}
				if ( ( ! $this.css( 'height' ) && ! $this.css( 'width' ) ) && ( isNaN( $this.attr( 'height' ) ) || isNaN( $this.attr( 'width' ) ) ) ) {
					$this.attr( 'height', 9 );
					$this.attr( 'width', 16 );
				}
				var height = ( this.tagName.toLowerCase() === 'object' || ( $this.attr( 'height' ) && ! isNaN( parseInt( $this.attr( 'height' ), 10 ) ) ) ) ? parseInt( $this.attr( 'height' ), 10 ) : $this.height(),
					width = ! isNaN( parseInt( $this.attr( 'width' ), 10 ) ) ? parseInt( $this.attr( 'width' ), 10 ) : $this.width(),
					aspectRatio = height / width;
				if ( ! $this.attr( 'id' ) ) {
					var videoID = 'fitvid' + count;
					$this.attr( 'id', videoID );
				}
				$this.wrap( '<div class="fluid-width-video-wrapper"></div>' ).parent( '.fluid-width-video-wrapper' ).css( 'padding-top', ( aspectRatio * 100 ) + '%' );
				$this.removeAttr( 'height' ).removeAttr( 'width' );
			});
		});
	};
// Works with either jQuery or Zepto
})( window.jQuery || window.Zepto );

/*!
 * Lazy Load - jQuery plugin for lazy loading images
 *
 * Copyright (c) 2007-2015 Mika Tuupola
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * Project home:
 *   http://www.appelsiini.net/projects/lazyload
 *
 * Version:  1.9.7
 *
 */
(function( $, window, document, undefined ) {
	var $window = $( window );

	$.fn.lazyload = function( options ) {
		var elements = this;
		var $container;
		var settings = {
			threshold: 0,
			failure_limit: 0,
			event: 'scroll',
			effect: 'show',
			container: window,
			data_attribute: 'original',
			skip_invisible: false,
			appear: null,
			load: null,
			placeholder: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC'
		};

		function update() {
			var counter = 0;

			elements.each(function() {
				var $this = $( this );
				if ( settings.skip_invisible && ! $this.is( ':visible' ) ) {
					return;
				}
				if ( $.abovethetop( this, settings ) ||
						$.leftofbegin( this, settings ) ) {
					/* Nothing. */
				} else if ( ! $.belowthefold( this, settings ) &&
						! $.rightoffold( this, settings ) ) {
					$this.trigger( 'appear' );
					/* if we found an image we'll load, reset the counter */
					counter = 0;
				} else {
					if ( ++counter > settings.failure_limit ) {
						return false;
					}
				}
			});

		}

		if ( options ) {
			/* Maintain BC for a couple of versions. */
			if ( undefined !== options.failurelimit ) {
				options.failure_limit = options.failurelimit;
				delete options.failurelimit;
			}
			if ( undefined !== options.effectspeed ) {
				options.effect_speed = options.effectspeed;
				delete options.effectspeed;
			}

			$.extend( settings, options );
		}

		/* Cache container as jQuery as object. */
		$container = ( settings.container === undefined ||
		settings.container === window ) ? $window : $( settings.container );

		/* Fire one scroll event per scroll. Not one scroll event per image. */
		if ( 0 === settings.event.indexOf( 'scroll' ) ) {
			$container.bind( settings.event, function() {
				return update();
			});
		}

		this.each(function() {
			var self = this;
			var $self = $( self );

			self.loaded = false;

			/* If no src attribute given use data:uri. */
			if ( $self.attr( 'src' ) === undefined || $self.attr( 'src' ) === false ) {
				if ( $self.is( 'img' ) ) {
					$self.attr( 'src', settings.placeholder );
				}
			}

			/* When appear is triggered load original image. */
			$self.one( 'appear', function() {
				if ( ! this.loaded ) {
					if ( settings.appear ) {
						var elements_left = elements.length;
						settings.appear.call( self, elements_left, settings );
					}
					$( '<img />' )
						.bind( 'load', function() {

							var original = $self.attr( 'data-' + settings.data_attribute );
							$self.hide();
							if ( $self.is( 'img' ) ) {
								$self.attr( 'src', original ).attr('alt', '');
							} else {
								$self.css( 'background-image', 'url(\'' + original + '\')' );
							}
							$self[ settings.effect ]( settings.effect_speed );

							self.loaded = true;

							/* Remove image from array so it is not looped next time. */
							var temp = $.grep( elements, function( element ) {
								return ! element.loaded;
							});
							elements = $( temp );

							if ( settings.load ) {
								var elements_left = elements.length;
								settings.load.call( self, elements_left, settings );
							}
						})
						.attr( 'src', $self.attr( 'data-' + settings.data_attribute ) );
				}
			});

			/* When wanted event is triggered load original image */
			/* by triggering appear.                              */
			if ( 0 !== settings.event.indexOf( 'scroll' ) ) {
				$self.bind( settings.event, function() {
					if ( ! self.loaded ) {
						$self.trigger( 'appear' );
					}
				});
			}
		});

		/* Check if something appears when window is resized. */
		$window.bind( 'resize', function() {
			update();
		});

		/* With IOS5 force loading images when navigating with back button. */
		/* Non optimal workaround. */
		if ( ( /(?:iphone|ipod|ipad).*os 5/gi ).test( navigator.appVersion ) ) {
			$window.bind( 'pageshow', function( event ) {
				if ( event.originalEvent && event.originalEvent.persisted ) {
					elements.each(function() {
						$( this ).trigger( 'appear' );
					});
				}
			});
		}

		/* Force initial check if images should appear. */
		$( document ).ready(function() {
			update();
		});

		return this;
	};

	/* Convenience methods in jQuery namespace.           */
	/* Use as  $.belowthefold(element, {threshold : 100, container : window}) */

	$.belowthefold = function( element, settings ) {
		var fold;

		if ( settings.container === undefined || settings.container === window ) {
			fold = ( window.innerHeight ? window.innerHeight : $window.height() ) + $window.scrollTop();
		} else {
			fold = $( settings.container ).offset().top + $( settings.container ).height();
		}

		return fold <= $( element ).offset().top - settings.threshold;
	};

	$.rightoffold = function( element, settings ) {
		var fold;

		if ( settings.container === undefined || settings.container === window ) {
			fold = $window.width() + $window.scrollLeft();
		} else {
			fold = $( settings.container ).offset().left + $( settings.container ).width();
		}

		return fold <= $( element ).offset().left - settings.threshold;
	};

	$.abovethetop = function( element, settings ) {
		var fold;

		if ( settings.container === undefined || settings.container === window ) {
			fold = $window.scrollTop();
		} else {
			fold = $( settings.container ).offset().top;
		}

		return fold >= $( element ).offset().top + settings.threshold + $( element ).height();
	};

	$.leftofbegin = function( element, settings ) {
		var fold;

		if ( settings.container === undefined || settings.container === window ) {
			fold = $window.scrollLeft();
		} else {
			fold = $( settings.container ).offset().left;
		}

		return fold >= $( element ).offset().left + settings.threshold + $( element ).width();
	};

	$.inviewport = function( element, settings ) {
		return ! $.rightoffold( element, settings ) && ! $.leftofbegin( element, settings ) &&
			! $.belowthefold( element, settings ) && ! $.abovethetop( element, settings );
	};

	/* Custom selectors for your convenience.   */
	/* Use as $("img:below-the-fold").something() or */
	/* $("img").filter(":below-the-fold").something() which is faster */

	$.extend( $.expr[':'], {
		'below-the-fold': function( a ) {
			return $.belowthefold( a, { threshold: 0 });
		},
		'above-the-top': function( a ) {
			return ! $.belowthefold( a, { threshold: 0 });
		},
		'right-of-screen': function( a ) {
			return $.rightoffold( a, { threshold: 0 });
		},
		'left-of-screen': function( a ) {
			return ! $.rightoffold( a, { threshold: 0 });
		},
		'in-viewport': function( a ) {
			return $.inviewport( a, { threshold: 0 });
		},
		/* Maintain BC for couple of versions. */
		'above-the-fold': function( a ) {
			return ! $.belowthefold( a, { threshold: 0 });
		},
		'right-of-fold': function( a ) {
			return $.rightoffold( a, { threshold: 0 });
		},
		'left-of-fold': function( a ) {
			return ! $.rightoffold( a, { threshold: 0 });
		}
	});
})( jQuery, window, document );

jQuery( document ).ready(function( $ ) {
    window.addEventListener('scroll', function() {
        if ($(window).width() >= 14400) {
            const sidebar = document.getElementById('sidebar');
            const stickyPosition = 120;
        
            if (window.pageYOffset > stickyPosition) {
                sidebar.classList.add('fixed');
            } else {
                sidebar.classList.remove('fixed');
            }
        } else {
            sidebar.classList.remove('fixed');
        }
    });


	var $contentWrap = $( '#content-wrap' );

	$contentWrap.fitVids();

	// Show/hide the responsive menu
    $( '.menu-toggle' ).click(function() {
        $( "body" ).removeClass( "search-open" );
        $( "body" ).toggleClass("menu-open");
    });

    $( '.hamburger-toggle-wrap' ).on( 'click', function (e) {
        e.preventDefault();
        $('.search-primary').addClass('hidden');
        $( "body" ).removeClass( "search-open" );
        $( "body" ).toggleClass("menu-open");
        $( '#hamburger' ).toggleClass( 'hidden' );
    } );

    // Show/hide the search bar
    $( '.search-toggle' ).click(function() {
        $( "body" ).removeClass("menu-open");
        $( "body" ).toggleClass("search-open");
    });

    $('.search-toggle-desktop').on('click', function (e) {
        e.preventDefault();
        $( '#hamburger' ).addClass( 'hidden' );
        $( "body" ).removeClass("menu-open");
        $( "body" ).toggleClass("search-open");
        $('.search-primary').toggleClass('hidden');
    });

    // Close the responsive menu and search bar when you click outside of it
    // Part 1: Close it when you click anywhere
    $( 'html' ).click( function(){
        // Menu
        if ( $( "body" ).hasClass( "menu-open" ) ) {
            $( ".menu-toggle, .hamburger-toggle-wrap" ).click();
            $( "body" ).removeClass( "menu-open" );
            $( '#hamburger' ).addClass( 'hidden' );
        }
        // Search bar
        if ( $( "body" ).hasClass( "search-open" ) ) {
            $( ".search-toggle, .search-toggle-desktop" ).click();
            $( "body" ).removeClass( "search-open" );
            $('.search-primary').addClass('hidden');
        }
    });

    // Part 2: Except when you click on the header (which contains the menu)
    $( '.header' ).click(function(event){
        event.stopPropagation();
    });

	$( window ).scroll( function() {
		var scroll = $( this ).scrollTop()
		if ( scroll > 200 && ! $( '.scroll-nav' ).hasClass( 'shown' ) ) {
			$( '.scroll-nav' ).addClass( 'shown' );
			$( '#hamburger' ).addClass( 'hidden' );
			$('.search-primary').addClass('hidden');
		} else if ( scroll <= 200 ) {
			$( '.scroll-nav' ).removeClass( 'shown' );
		}
	});

    function makeid(length) {
        var result           = [];
        var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        var charactersLength = characters.length;
        for ( var i = 0; i < length; i++ ) {
            result.push(characters.charAt(Math.floor(Math.random() *
                charactersLength)));
        }
        return result.join('');
    }
    
    if (typeof tocEnabled !== 'undefined' && tocEnabled !== "1") {
        $('#table-of-contents').html('');
        var tableOfContent = '.entry-content h1, .entry-content h2, .entry-content h3, .entry-content h4, .entry-content h5, .entry-content h6';
    
        $(tableOfContent).each(function(index, el) {
            var id = makeid(10)
            $(el).attr('id', id);
    
            $('#table-of-contents').append('<li class="pl-' + parseInt(el.nodeName.replace(/h/i, '')) + '"><a rel="nofollow" aria-hidden="true" data-id="' + id + '">' + $(el).text() + '</a></li>');
        });
    
        if ($(".table-of-contents ul li a").length <= 2) {
            $('.table-of-contents').remove();
        }
    
        var tocSticky = false;
        var originalTop = 0;
    
        function setSticky() {
            if ($(window).width() >= 1440) {
                tocSticky = true;
                let headerHeight = 120; // Set header height to 120px
                let windowHeight = window.innerHeight;
                let availableHeight = windowHeight - headerHeight;
                
                // Calculate the height of the TOC content
                let tocContentHeight = $(".table-of-contents ul").outerHeight();
                
                // Set the TOC height to either the content height plus 70px or 65% of available height, whichever is smaller
                let tocHeight = Math.min(tocContentHeight + 70, availableHeight * 0.65);
    
                originalTop = headerHeight + (availableHeight - tocHeight) / 2;
    
                $(".table-of-contents").css({
                    'position': 'fixed',
                    'top': originalTop + 'px',
                    'height': tocHeight + 'px',
                    'overflow-y': 'auto',
                    'margin-left': '-220px',
                    'scrollbar-width': 'none', // Firefox
                    '-ms-overflow-style': 'none' // IE 10+
                });
    
                // Hide webkit scrollbar
                $(".table-of-contents").append('<style>.table-of-contents::-webkit-scrollbar { width: 0 !important }</style>');
            }
        }
    
        function updateTocPosition() {
            if (tocSticky && $(window).width() >= 1440) {
                let $toc = $(".table-of-contents");
                let $rpbt = $("div.rpbt_shortcode");
                let tocHeight = $toc.outerHeight();
                let tocBottom = $toc.offset().top + tocHeight;
                let rpbtTop = $rpbt.offset().top;
                let scrollTop = $(window).scrollTop();
                let clientHeight = $(window).height();
                
                // Calculate the position where TOC should become fixed again
                let fixedThreshold = rpbtTop + (tocHeight * 0.5);
    
                if (scrollTop + (clientHeight / 2) + (tocHeight * 0.5) >= rpbtTop) {
                    // TOC bottom is at or below rpbt top, fix it to the bottom
                    let newTopPosition = rpbtTop - tocHeight;
                    $toc.css({
                        'position': 'absolute',
                        'top': newTopPosition + 'px'
                    });
                } else if (scrollTop < fixedThreshold) {
                    // Scroll position is above the threshold, make TOC sticky again
                    $toc.css({
                        'position': 'fixed',
                        'top': originalTop + 'px'
                    });
                }
                // If neither condition is met, do nothing (TOC remains in its current state)
            }
        }
    
        var throttledUpdateTocPosition = _.throttle(updateTocPosition, 10);
    
        $(window).on('scroll resize', throttledUpdateTocPosition);
    
        window.addEventListener('resize', function(event) {
            if ($(window).width() >= 1440) {
                setSticky();
                updateTocPosition();
            } else {
                $(".table-of-contents").css({
                    'position': '',
                    'top': '',
                    'height': '',
                    'overflow-y': '',
                    'margin-left': '',
                    'scrollbar-width': '',
                    '-ms-overflow-style': ''
                });
                $(".table-of-contents .toc-fade").remove();
                tocSticky = false;
            }
        }, true);
        setSticky();
        updateTocPosition();
    
        $(".table-of-contents").addClass('show');
    
        $(".table-of-contents ul li a").bind('click', function(event) {
            $(this).parent().addClass('current');
            $('html, body').animate({
                scrollTop: $('#' + $(this).attr('data-id')).offset().top - 120 // Adjust for header height
            }, 500);
        });
    
        /* Table of Contents with Scrolling Active States */
        const observer = new IntersectionObserver(entries => {
            var IDs = []
            entries.forEach(entry => {
                var id = entry.target.getAttribute('id')
                if (document.querySelector(`#table-of-contents li a[data-id="${id}"]`)) {
                    if (entry.intersectionRatio > 0) {
                        IDs.push(id);
                    }
                }
            });
    
            var stop = false;
    
            if (IDs.length > 0) {
                $('#table-of-contents li').removeClass('current');
                document.querySelectorAll('#table-of-contents li a').forEach((item) => {
                    var itemId = item.getAttribute('data-id')
                    if (IDs.indexOf(itemId) !== -1 && !stop) {
                        const currentItem = document.querySelector(`#table-of-contents li a[data-id="${itemId}"]`).parentElement;
                        currentItem.classList.add('current');
                        stop = true;
    
                        // Center the current item
                        const tocContainer = document.querySelector('.table-of-contents');
                        const tocContainerHeight = tocContainer.offsetHeight;
                        const currentItemOffset = currentItem.offsetTop;
                        const currentItemHeight = currentItem.offsetHeight;
                        const scrollPosition = currentItemOffset - (tocContainerHeight / 2) + (currentItemHeight / 2);
                        
                        tocContainer.scrollTo({
                            top: scrollPosition,
                            behavior: 'smooth'
                        });
                    }
                });
            }
        });
    
        // Track all sections that have an `id` applied
        document.querySelectorAll('.entry-content h2[id], .entry-content h3[id], .entry-content h4[id], .entry-content h5[id], .entry-content h6[id]').forEach((section) => {
            observer.observe(section);
        });
    }

    $('.dummyLazyOn').each(function(){
        if ($(this).attr('data-dummy-lazy-bg')) $(this).css('background-image', 'url('+$(this).attr('data-dummy-lazy-bg')+')');
    });

    $(window).scroll(function(){
        $('.dummyLazy').each(function(){
            if ($(this).attr('data-dummy-lazy-bg')) $(this).css('background-image', 'url('+$(this).attr('data-dummy-lazy-bg')+')');
        });
    })

    $('#hamburger .menu a').click(function(e){
        if ($(this).attr('data-object') == 'category') {
            e.preventDefault();
            let catId =  $(this).attr('data-id'),
                name = $(this).text(),
                link = $(this).attr('href');

            $('#hamburger > div').hide();

            $('#hamburger .posts_container').show();
            $('#hamburger .posts_container .posts_listing .posts_category').hide();
            $('#hamburger .posts_container .category_title').text(name);
            $('#hamburger .posts_container .category_link a').attr('href', link);
            $('#hamburger .posts_container .posts_listing .posts_category.cat_selector_'+catId).show();
        }
    });
    $('#hamburger .get_back_link a').click(function(e){
        e.preventDefault();
        $('#hamburger > div').show();
        $('#hamburger .posts_container').hide();
    });

    // Function to calculate and update sidebar position
    function updateSidebarPosition() {
        // Get required elements
        const sidebarContent = document.querySelector('.sidebar-content');
        const siteFooter = document.querySelector('.site-footer');
        const snigelAd = document.querySelector('#adngin-_bottom_adhesive_dskt-0-adhesive');
        const mainContent = document.querySelector('body'); // Assuming this is your main content wrapper
        
        // Get current dimensions and positions
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const mainContentHeight = mainContent.offsetHeight;
        const sidebarHeight = sidebarContent.offsetHeight;
        const footerHeight = siteFooter.offsetHeight;
        const snigelAdHeight = snigelAd ? snigelAd.offsetHeight * 2 : 0;
        
        // Calculate threshold point
        const threshold = mainContentHeight - sidebarHeight - footerHeight - snigelAdHeight;
        
        // Update sidebar position
        if (scrollTop > threshold) {
            document.getElementById('sidebar').classList.add('fixed-bottom');
        } else {
            // Reset position
            document.getElementById('sidebar').classList.remove('fixed-bottom');
        }
    }

    // Add scroll event listener with throttling for performance
    let ticking = false;
    window.addEventListener('scroll', () => {
        if (!ticking) {
            window.requestAnimationFrame(() => {
                updateSidebarPosition();
                ticking = false;
            });
            ticking = true;
        }
    });

    // Handle window resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            updateSidebarPosition();
        }, 100);
    });

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
        updateSidebarPosition();
    });
});